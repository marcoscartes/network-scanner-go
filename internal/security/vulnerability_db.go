package security

import (
	"encoding/json"
	"network-scanner-go/internal/database"
	"os"
	"path/filepath"
)

// VulnerabilityRule represents a security rule
type VulnerabilityRule struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Port        int      `json:"port"`
	Severity    string   `json:"severity"` // low, medium, high, critical
	Description string   `json:"description"`
	Solution    string   `json:"solution"`
	MoreInfo    string   `json:"more_info"`
	Types       []string `json:"types,omitempty"` // Only apply to these device types
}

var rules []VulnerabilityRule

// LoadRules loads security rules from a JSON file
func LoadRules(configPath string) error {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return err
	}

	return json.Unmarshal(data, &rules)
}

// CheckDevice checks a device for vulnerabilities
func CheckDevice(openPorts []int, deviceType string) []database.Vulnerability {
	matches := make([]database.Vulnerability, 0)

	for _, rule := range rules {
		// ... (keep logic but use database.Vulnerability)
		if rule.Port > 0 {
			portFound := false
			for _, p := range openPorts {
				if p == rule.Port {
					portFound = true
					break
				}
			}

			if portFound {
				// Check if rule is type-specific
				if len(rule.Types) > 0 {
					typeMatch := false
					for _, t := range rule.Types {
						if t == deviceType {
							typeMatch = true
							break
						}
					}
					if !typeMatch {
						continue
					}
				}

				matches = append(matches, database.Vulnerability{
					RuleID:      rule.ID,
					Name:        rule.Name,
					Severity:    rule.Severity,
					Description: rule.Description,
					Solution:    rule.Solution,
					MoreInfo:    rule.MoreInfo,
					Port:        rule.Port,
				})
			}
		}
	}

	return matches
}

// GetDefaultRulesPath returns the likely path for security rules
func GetDefaultRulesPath() string {
	return filepath.Join("configs", "security_rules.json")
}
