package security

import (
	"encoding/json"
	"fmt"
	"network-scanner-go/internal/database"
	"os"
	"path/filepath"
)

// VulnerabilityRule represents a security rule
type VulnerabilityRule struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Port        int      `json:"port"`
	Severity    string   `json:"severity"` // low, medium, high, critical
	Description string   `json:"description"`
	Solution    string   `json:"solution"`
	MoreInfo    string   `json:"more_info"`
	CVEKeyword  string   `json:"cve_keyword,omitempty"` // Keyword to search in CVE DBs
	Types       []string `json:"types,omitempty"`       // Only apply to these device types
}

var rules []VulnerabilityRule

// LoadRules loads security rules from a JSON file
func LoadRules(configPath string) error {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return err
	}

	return json.Unmarshal(data, &rules)
}

// CheckDevice checks a device for vulnerabilities
func CheckDevice(openPorts []int, deviceType string) []database.Vulnerability {
	matches := make([]database.Vulnerability, 0)

	for _, rule := range rules {
		// ... (keep logic but use database.Vulnerability)
		if rule.Port > 0 {
			portFound := false
			for _, p := range openPorts {
				if p == rule.Port {
					portFound = true
					break
				}
			}

			if portFound {
				// Check if rule is type-specific
				if len(rule.Types) > 0 {
					typeMatch := false
					for _, t := range rule.Types {
						if t == deviceType {
							typeMatch = true
							break
						}
					}
					if !typeMatch {
						continue
					}
				}

				matches = append(matches, database.Vulnerability{
					RuleID:      rule.ID,
					Name:        rule.Name,
					Severity:    rule.Severity,
					Description: rule.Description,
					Solution:    rule.Solution,
					MoreInfo:    rule.MoreInfo,
					Port:        rule.Port,
				})

				// If there's a CVE keyword, search for CVEs (in a real app this would be async or background)
				if rule.CVEKeyword != "" {
					cveVulns := SearchCVEsForKeyword(rule.CVEKeyword)
					matches = append(matches, cveVulns...)
				}
			}
		}
	}

	return matches
}

// SearchCVEsForKeyword searches for recent CVEs related to a keyword
func SearchCVEsForKeyword(keyword string) []database.Vulnerability {
	// Note: In a real app we'd search the database for all CVEs related to this keyword
	// For this implementation, we'll use the API and cache individual results.
	// Since we don't have a keyword->cve_list mapping in DB yet, we skip global cache check for now
	// but individual CVE details ARE cached.

	client := NewCVEClient()
	resp, err := client.SearchByKeyword(keyword)
	if err != nil {
		return nil
	}

	vulns := make([]database.Vulnerability, 0)
	// Limit to top 3 most recent/critical CVEs for simplicity
	count := 0
	for _, v := range resp.Vulnerabilities {
		if count >= 3 {
			break
		}

		severity := "medium"
		if len(v.CVE.Metrics.CvssMetricV31) > 0 {
			severity = v.CVE.Metrics.CvssMetricV31[0].CvssData.BaseSeverity
		}

		desc := ""
		for _, d := range v.CVE.Descriptions {
			if d.Lang == "en" {
				desc = d.Value
				break
			}
		}

		vulns = append(vulns, database.Vulnerability{
			RuleID:      v.CVE.ID,
			Name:        fmt.Sprintf("%s: %s", v.CVE.ID, keyword),
			Severity:    severity,
			Description: desc,
			Solution:    "Check official vendor security advisory for patch information.",
			MoreInfo:    fmt.Sprintf("https://nvd.nist.gov/vuln/detail/%s", v.CVE.ID),
		})

		// Cache it
		var score float64
		if len(v.CVE.Metrics.CvssMetricV31) > 0 {
			score = v.CVE.Metrics.CvssMetricV31[0].CvssData.BaseScore
		}
		database.SaveCVECache(v.CVE.ID, desc, severity, score, v.CVE.Published, v.CVE.LastModified)

		count++
	}

	return vulns
}

// GetDefaultRulesPath returns the likely path for security rules
func GetDefaultRulesPath() string {
	return filepath.Join("configs", "security_rules.json")
}
